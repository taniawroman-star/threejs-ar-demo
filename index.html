<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>WebXR AR Cube — Example</title>
  <style>
    html,body { height:100%; margin:0; overflow:hidden; font-family: system-ui, Arial; }
    #overlay { position: absolute; left:0;right:0;top:0; padding:12px; pointer-events:none; color:#fff; text-shadow:0 1px 2px rgba(0,0,0,.6); }
    #startMsg { pointer-events:auto; display:inline-block; background:rgba(0,0,0,.5); padding:8px 12px; border-radius:8px; }
    canvas { display:block; }
  </style>
</head>
<body>
  <div id="overlay"><div id="startMsg">Tap "Enter AR" to start — then tap on a surface to place a cube.</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.0/build/three.module.js';
    import { ARButton } from 'https://unpkg.com/three@0.152.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let reticle, controller;

    init();
    
    function init(){
      const container = document.body;

      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.xr.enabled = true;
      container.appendChild(renderer.domElement);

      // Light
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      light.position.set(0.5, 1, 0.25);
      scene.add(light);

      // Reticle — shows where a hit-test found a surface
      const ring = new THREE.RingGeometry(0.07, 0.1, 32).rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x0fff0, side: THREE.DoubleSide });
      reticle = new THREE.Mesh(ring, ringMat);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Controller (for select events)
      controller = renderer.xr.getController(0);
      controller.addEventListener('select', onSelect);
      scene.add(controller);

      // AR button
      document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

      // Resize
      window.addEventListener('resize', onWindowResize, false);

      // Animation loop
      renderer.setAnimationLoop(render);

      // Setup a basic cube to clone when placing
      // We'll keep the geometry/material ready (not added to scene)
      const cubeGeometry = new THREE.BoxGeometry(0.12, 0.12, 0.12);
      const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0x156289, roughness: 0.6, metalness: 0.2 });
      // store on global so onSelect can use
      window._AR_CUBE = { geometry: cubeGeometry, material: cubeMaterial };

      // Request hit-test source once session starts
      renderer.xr.addEventListener('sessionstart', async () => {
        const session = renderer.xr.getSession();
        // Reference space for hit testing
        const viewerRefSpace = await session.requestReferenceSpace('viewer');
        // request a transient hit test source from the viewer
        const hitTestSource = await session.requestHitTestSource({ space: viewerRefSpace });
        // attach to renderer.userData for use in render loop
        renderer.userData.hitTestSource = hitTestSource;

        // create a reference space for the scene
        renderer.userData.localReferenceSpace = await session.requestReferenceSpace('local');

        // remove start message
        const startMsg = document.getElementById('startMsg');
        if (startMsg) startMsg.style.display = 'none';
      });

      renderer.xr.addEventListener('sessionend', () => {
        // cleanup
        if (renderer.userData.hitTestSource) {
          renderer.userData.hitTestSource.cancel();
          renderer.userData.hitTestSource = null;
        }
        const startMsg = document.getElementById('startMsg');
        if (startMsg) startMsg.style.display = 'inline-block';
      });
    }

    function onWindowResize(){
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onSelect(){
      // When user 'select's (tap), place a cube at the reticle position (if visible)
      if (!reticle.visible) return;
      const { geometry, material } = window._AR_CUBE;
      const mesh = new THREE.Mesh(geometry, material);
      // apply reticle's matrix (position & orientation)
      mesh.applyMatrix4(reticle.matrix);
      mesh.scale.set(1,1,1);
      scene.add(mesh);
    }

    function render(timestamp, frame){
      if (frame) {
        const referenceSpace = renderer.userData.localReferenceSpace;
        const hitTestSource = renderer.userData.hitTestSource;

        if (hitTestSource && referenceSpace) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            // copy pose into reticle.matrix
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    // Fallback message if no immersive-ar support
    if (navigator.xr === undefined) {
      const msg = document.createElement('div');
      msg.style.position = 'absolute';
      msg.style.bottom = '16px';
      msg.style.left = '16px';
      msg.style.padding = '10px';
      msg.style.background = 'rgba(0,0,0,0.6)';
      msg.style.color = 'white';
      msg.style.borderRadius = '6px';
      msg.textContent = 'WebXR not available in this browser. Try Chrome on Android with WebXR enabled.';
      document.body.appendChild(msg);
    }

  </script>
</body>
</html>
